const fs = require('fs').promises;
const path = require('path');
const postcss = require('postcss');
// const cascadeLayers = require('@csstools/postcss-cascade-layers');
const glob = require('glob');

// Simplified PostCSS processor focusing on cascade layers
const processor = postcss([
//   cascadeLayers()
]);

async function processCSS() {
  try {
    console.log('üöÄ Starting CSS processing...');

    // Find all CSS files in styles directory
    const cssFiles = glob.sync('styles/**/*.css');
    console.log(`üìÅ Found ${cssFiles.length} CSS files:`, cssFiles);

    const processedCSSFiles = [];

    // Process each CSS file
    for (const file of cssFiles.sort()) {
      console.log(`‚öôÔ∏è  Processing ${file}...`);

      let cssContent = await fs.readFile(file, 'utf8');

      // Strip problematic CSS rules with \ ! syntax
      const originalLength = cssContent.length;
      cssContent = stripProblematicRules(cssContent);
      const processedLength = cssContent.length;

      if (originalLength !== processedLength) {
        console.log(`üîß Stripped problematic CSS rules from ${file} (${originalLength} -> ${processedLength} chars)`);
      }

      // Save the processed CSS for debugging
      const debugFileName = `debug-${path.basename(file, '.css')}-after-strip.css`;
      await fs.writeFile(debugFileName, cssContent);
      console.log(`üêõ Debug: Saved CSS after stripProblematicRules to ${debugFileName}`);

      // Process with PostCSS
      try {
        const result = await processor.process(cssContent, {
          from: file,
          to: undefined
        });

        // Apply minification
        let minifiedCSS = minifyCSS(result.css);

        // Store processed file info
        const fileName = path.basename(file, '.css');
        processedCSSFiles.push({
          originalPath: file,
          fileName: fileName,
          variableName: generateVariableName(fileName),
          content: minifiedCSS
        });

        console.log(`‚úÖ Processed ${file} successfully with PostCSS`);

      } catch (error) {
        console.error(`‚ùå PostCSS processing failed for ${file}:`, error.message);
        process.exit(1);
      }
    }

    console.log(`üìè Processed ${processedCSSFiles.length} CSS files`);

    // Generate Objective-C header
    const headerContent = generateObjCHeader(processedCSSFiles);

    // Write the header file
    await fs.writeFile('ChatGPTWebLegacyCompatCSS.h', headerContent);
    console.log('‚úÖ Generated ChatGPTWebLegacyCompatCSS.h');

    // Also write each processed CSS file for reference
    for (const fileInfo of processedCSSFiles) {
      await fs.writeFile(`processed-${fileInfo.fileName}.css`, fileInfo.content);
      console.log(`‚úÖ Generated processed-${fileInfo.fileName}.css`);
    }

    console.log('üéâ Build completed successfully!');

  } catch (error) {
    console.error('‚ùå Error during processing:', error);
    process.exit(1);
  }
}

function minifyCSS(css) {
  // Basic CSS minification
  return css
    // Remove comments
    .replace(/\/\*[\s\S]*?\*\//g, '')
    // Remove unnecessary whitespace
    .replace(/\s+/g, ' ')
    // Remove whitespace around specific characters
    .replace(/\s*{\s*/g, '{')
    .replace(/\s*}\s*/g, '}')
    .replace(/\s*;\s*/g, ';')
    .replace(/\s*,\s*/g, ',')
    .replace(/\s*:\s*/g, ':')
    // Remove trailing semicolons before }
    .replace(/;}/g, '}')
    // Trim
    .trim();
}

function generateVariableName(fileName) {
  // Convert filename to a valid Objective-C variable name
  // e.g., "conversation-small" -> "kChatGPTWebLegacyCompatConversationSmallCSS"
  const camelCase = fileName
    .split(/[-_]/)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join('');

  return `kChatGPTWebLegacyCompat${camelCase}CSS`;
}

function generateObjCHeader(cssFiles) {
  let headerContent = `//
//  ChatGPTWebLegacyCompatCSS.h
//  ChatGPTWebLegacyCompat
//
//  Generated automatically by build script
//  Do not edit this file manually
//

#ifndef ChatGPTWebLegacyCompatCSS_h
#define ChatGPTWebLegacyCompatCSS_h

#import <Foundation/Foundation.h>

// Processed and minified CSS for ChatGPT web legacy compatibility
// These CSS files have been transformed to be compatible with older WebKit versions
// and include fallbacks for modern CSS features like cascade layers

`;

  // Generate NSString variables for each CSS file
  for (const fileInfo of cssFiles) {
    // Escape the CSS content for Objective-C string
    const escapedCSS = fileInfo.content
      .replace(/\\/g, '\\\\')  // Escape backslashes (this will handle CSS escape sequences like \32)
      .replace(/"/g, '\\"')    // Escape quotes
      .replace(/\n/g, '\\n')   // Escape newlines
      .replace(/\r/g, '\\r');   // Escape carriage returns

    // Split into chunks of reasonable length to avoid compiler limits
    const maxLineLength = 500;
    const lines = [];
    let currentLine = '';

    for (let i = 0; i < escapedCSS.length; i++) {
      currentLine += escapedCSS[i];
      if (currentLine.length >= maxLineLength && (escapedCSS[i] === ' ' || escapedCSS[i] === '}')) {
        lines.push(currentLine);
        currentLine = '';
      }
    }
    if (currentLine) {
      lines.push(currentLine);
    }

    const stringLiterals = lines.map(line => `    @"${line}"`).join(' \\\n');

    headerContent += `// CSS from ${fileInfo.originalPath}
static NSString *const ${fileInfo.variableName} = \\
${stringLiterals};

`;
  }

  headerContent += `#endif /* ChatGPTWebLegacyCompatCSS_h */
`;

  return headerContent;
}

function stripProblematicRules(cssContent) {
  // Remove CSS rules with problematic syntax that can't be parsed by PostCSS

  let processed = cssContent;

  // Remove rules with selectors containing \ ! patterns
  processed = processed.replace(/[^{}]*\\\s*![^{]*\{[^}]*\}/g, '');

  return processed.trim();
}

// Check for watch mode
const isWatchMode = process.argv.includes('--watch');

if (isWatchMode) {
  console.log('üëÄ Watch mode enabled. Watching for changes...');
  const chokidar = require('chokidar');

  // Watch styles directory
  chokidar.watch('styles/**/*.css').on('change', (path) => {
    console.log(`üìù File changed: ${path}`);
    processCSS();
  });

  // Initial build
  processCSS();
} else {
  // Single build
  processCSS();
}
