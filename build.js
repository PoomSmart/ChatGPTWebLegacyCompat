const fs = require('fs').promises;
const path = require('path');
const postcss = require('postcss');
const glob = require('glob');

const processor = postcss();

async function processCSS() {
  try {
    console.log('üöÄ Starting CSS processing...');

    // Find all CSS files in styles directory
    const cssFiles = glob.sync('styles/**/*.css');
    console.log(`üìÅ Found ${cssFiles.length} CSS files:`, cssFiles);

    let combinedCSS = '';

    // Process each CSS file
    for (const file of cssFiles) {
      console.log(`‚öôÔ∏è  Processing ${file}...`);

      let cssContent = await fs.readFile(file, 'utf8');

      // Strip problematic CSS rules with \ ! syntax
      const originalLength = cssContent.length;
      cssContent = stripProblematicRules(cssContent);
      const processedLength = cssContent.length;

      if (originalLength !== processedLength) {
        console.log(`üîß Stripped problematic CSS rules from ${file} (${originalLength} -> ${processedLength} chars)`);
      }

      // Save the processed CSS for debugging
      const debugFileName = `debug-${path.basename(file, '.css')}-after-strip.css`;
      await fs.writeFile(debugFileName, cssContent);
      console.log(`üêõ Debug: Saved CSS after stripProblematicRules to ${debugFileName}`);

      // Process with PostCSS
      try {
        const result = await processor.process(cssContent, {
          from: file,
          to: undefined
        });

        // Apply minification
        let minifiedCSS = minifyCSS(result.css);

        // Add a comment to identify the source file
        combinedCSS += `${minifiedCSS}\n\n`;

        console.log(`‚úÖ Processed ${file} successfully with PostCSS`);

      } catch (error) {
        console.error(`‚ùå PostCSS processing failed for ${file}:`, error.message);
        process.exit(1);
      }
    }

    // Remove the last newlines
    combinedCSS = combinedCSS.trim();

    console.log(`üìè Combined CSS size: ${combinedCSS.length} characters`);

    // Generate Objective-C header
    const headerContent = generateObjCHeader(combinedCSS);

    // Write the header file
    await fs.writeFile('ChatGPTWebLegacyCompatCSS.h', headerContent);
    console.log('‚úÖ Generated ChatGPTWebLegacyCompatCSS.h');

    // Also write the processed CSS for reference
    await fs.writeFile('processed.css', combinedCSS);
    console.log('‚úÖ Generated processed.css');

    console.log('üéâ Build completed successfully!');

  } catch (error) {
    console.error('‚ùå Error during processing:', error);
    process.exit(1);
  }
}

function minifyCSS(css) {
  // Basic CSS minification
  return css
    // Remove comments
    .replace(/\/\*[\s\S]*?\*\//g, '')
    // Remove unnecessary whitespace
    .replace(/\s+/g, ' ')
    // Remove whitespace around specific characters
    .replace(/\s*{\s*/g, '{')
    .replace(/\s*}\s*/g, '}')
    .replace(/\s*;\s*/g, ';')
    .replace(/\s*,\s*/g, ',')
    .replace(/\s*:\s*/g, ':')
    // Remove trailing semicolons before }
    .replace(/;}/g, '}')
    // Trim
    .trim();
}

function generateObjCHeader(cssContent) {
  // Escape the CSS content for Objective-C string
  const escapedCSS = cssContent
    .replace(/\\/g, '\\\\')  // Escape backslashes (this will handle CSS escape sequences like \32)
    .replace(/"/g, '\\"')    // Escape quotes
    .replace(/\n/g, '\\n')   // Escape newlines
    .replace(/\r/g, '\\r');   // Escape carriage returns

  // Split into chunks of reasonable length to avoid compiler limits
  const maxLineLength = 500;
  const lines = [];
  let currentLine = '';

  for (let i = 0; i < escapedCSS.length; i++) {
    currentLine += escapedCSS[i];
    if (currentLine.length >= maxLineLength && (escapedCSS[i] === ' ' || escapedCSS[i] === '}')) {
      lines.push(currentLine);
      currentLine = '';
    }
  }
  if (currentLine) {
    lines.push(currentLine);
  }

  const stringLiterals = lines.map(line => `    @"${line}"`).join(' \\\n');

  return `//
//  ChatGPTWebLegacyCompatCSS.h
//  ChatGPTWebLegacyCompat
//
//  Generated automatically by build script
//  Do not edit this file manually
//

#ifndef ChatGPTWebLegacyCompatCSS_h
#define ChatGPTWebLegacyCompatCSS_h

#import <Foundation/Foundation.h>

// Processed and minified CSS for ChatGPT web legacy compatibility
// This CSS has been transformed to be compatible with older WebKit versions
// and includes fallbacks for modern CSS features like cascade layers
static NSString *const kChatGPTWebLegacyCompatCSS = \\
${stringLiterals};

#endif /* ChatGPTWebLegacyCompatCSS_h */
`;
}

function stripProblematicRules(cssContent) {
  // Remove CSS rules with problematic syntax that can't be parsed by PostCSS

  let processed = cssContent;

  // Remove rules with selectors containing \ ! patterns
  processed = processed.replace(/[^{}]*\\\s*![^{]*\{[^}]*\}/g, '');

  return processed.trim();
}

// Check for watch mode
const isWatchMode = process.argv.includes('--watch');

if (isWatchMode) {
  console.log('üëÄ Watch mode enabled. Watching for changes...');
  const chokidar = require('chokidar');

  // Watch styles directory
  chokidar.watch('styles/**/*.css').on('change', (path) => {
    console.log(`üìù File changed: ${path}`);
    processCSS();
  });

  // Initial build
  processCSS();
} else {
  // Single build
  processCSS();
}
